{"version":3,"sources":["components/CardItem.jsx","services/api.js","pages/Home.jsx","components/NewItem.jsx","pages/ShoppingCart.jsx","pages/Details.jsx","App.js","serviceWorker.js","index.js"],"names":["CardItem","this","props","products","addState","length","map","product","to","pathname","id","state","data-testid","key","title","className","src","thumbnail","alt","price","type","onClick","React","Component","getCategories","a","fetch","then","response","json","getProductsFromCategoryAndQuery","categoryId","query","Home","allCategories","inputQuery","category","getTextAndCategory","bind","requestButton","clearState","api","request","setState","results","target","value","name","getItemsFromCategoryAndQuery","anyCategory","htmlFor","onChange","NewItem","handleDelete","increaseQuantity","decreaseQuantity","quantity","ShoppingCart","shoppingCart","filterFunction","newList","filter","item","result","cart","reduce","acc","curr","includes","concat","emptyCart","index","Details","location","App","newCart","anyProduct","find","newArr","basename","process","exact","path","render","Boolean","window","hostname","match","ReactDOM","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.0325b04a.chunk.js","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport { Link } from 'react-router-dom';\nimport './CardItem.css';\n\nclass CardItem extends React.Component {\n  render() {\n    const { products, addState } = this.props;\n    const notFound = 'Nenhum produto foi encontrado';\n\n    return products.length === 0 ? notFound : (\n      products.map((product) => (\n        <>\n          {/* Para fazer a utilização de props em componentes <Link>\n          foi consultado um artigo em ui.dev\n          Source: https://ui.dev/react-router-v5-pass-props-to-link/ */}\n          <Link\n            to={ {\n              pathname: `/details/${product.id}`,\n              state: {\n                product,\n              },\n            } }\n            data-testid=\"product-detail-link\"\n          >\n            <div\n              data-testid=\"product\"\n              key={ product.title }\n            >\n              <p>{product.title}</p>\n              <img\n                className=\"card-image\"\n                src={ product.thumbnail }\n                alt={ product.title }\n              />\n              <p>{`R$ ${product.price}`}</p>\n            </div>\n          </Link>\n          <button\n            className=\"add-Item-Button\"\n            type=\"button\"\n            data-testid=\"product-add-to-cart\"\n            onClick={ () => addState(product) }\n          >\n            Adicionar ao carrinho\n          </button>\n        </>\n      ))\n    );\n  }\n}\nexport default CardItem;\n\nCardItem.propTypes = {\n  products: PropTypes.shape({\n    map: PropTypes.func.isRequired,\n    length: PropTypes.arrayOf().isRequired,\n  }).isRequired,\n  addState: PropTypes.func.isRequired,\n};\n","export async function getCategories() {\n  return fetch('https://api.mercadolibre.com/sites/MLB/categories')\n    .then((response) => response.json());\n}\n\nexport async function getProductsFromCategoryAndQuery(categoryId, query) {\n  return fetch(`https://api.mercadolibre.com/sites/MLB/search?category=${categoryId}&q=${query}`)\n    .then((response) => response.json());\n}\n\n// export async function getProductsFromQuery(query) {\n//   return fetch(`https://api.mercadolibre.com/sites/MLB/search?q=${query}`)\n//     .then((response) => response.json());\n// }\n\n// export async function getProductsFromCategoryId(id) {\n//   return fetch(`https://api.mercadolibre.com/sites/MLB/search?q=${id}`)\n//     .then((response) => response.json());\n// }\n","import React from 'react';\nimport { Link } from 'react-router-dom';\nimport PropTypes from 'prop-types';\nimport CardItem from '../components/CardItem';\nimport * as api from '../services/api';\n\nclass Home extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      allCategories: [],\n      inputQuery: '',\n      category: '',\n      response: [],\n    };\n\n    this.getTextAndCategory = this.getTextAndCategory.bind(this);\n    this.requestButton = this.requestButton.bind(this);\n    this.clearState = this.clearState.bind(this);\n  }\n\n  /** A função getCategories é chamada no componentDidMount para\n   * que tenhamos a lista de categorias armazenada, para renderi-\n   * zação posterior. */\n  componentDidMount() {\n    this.getCategories();\n  }\n\n  /** Função responsável por fazer requisições à API do Mercado\n   * Livre, de acordo com o que for passado por parâmetro. */\n  async getItemsFromCategoryAndQuery(category, inputQuery) {\n    const request = await api.getProductsFromCategoryAndQuery(category, inputQuery);\n    this.setState({\n      response: request.results,\n    });\n  }\n\n  /** Joga a lista de categorias para o state \"allCategories\" */\n  async getCategories() {\n    const response = await api.getCategories();\n    this.setState({\n      allCategories: response,\n    });\n  }\n\n  /** Função responsável por pegar dados do input e catagory e\n   * jogar para o state */\n  getTextAndCategory({ target }) {\n    const { value, name } = target;\n    this.setState({\n      [name]: value,\n    }, () => {\n      if (name === 'category') {\n        this.requestButton();\n      }\n    });\n  }\n\n  /** A função assíncrona requestButton é usada toda vez que\n   * o botão de pesquisar é acionado. Assim, a função getItemsFromCategoryAndQuery\n   * é chamada, fazendo a devida requisição.\n   * A função getItemsFromCategoryAndQuery também é chamada quando\n   * há click em alguma categoria, quando é feita uma vefificação\n   * na função acima chamada getTextAndCategory.\n   * */\n  async requestButton() {\n    this.clearState();\n    const { inputQuery, category } = this.state;\n    this.getItemsFromCategoryAndQuery(category, inputQuery);\n  }\n\n  /** Esta função clearState é chamada quando uma nova requisição\n   * é feita. Isso deve acontecer para que não tenhamos conflitos\n   * em novas requisições, quando novos itens se misturtam com os\n   * antigos */\n  clearState() {\n    this.setState({\n      response: [],\n    });\n  }\n\n  render() {\n    const { allCategories, response } = this.state;\n    const { addState } = this.props;\n    return (\n      <div className=\"main-page\">\n        <div className=\"categories\">\n          <aside>\n            <div className=\"category-form\">\n              {allCategories.map((anyCategory) => (\n                <button\n                  type=\"button\"\n                  key={ anyCategory.id }\n                  data-testid=\"category\"\n                  name=\"category\"\n                  value={ anyCategory.id }\n                  onClick={ this.getTextAndCategory }\n                >\n                  { anyCategory.name }\n                </button>\n              ))}\n            </div>\n          </aside>\n        </div>\n        <div>\n          <form className=\"search-bar\">\n            <label htmlFor=\"queryInput\" data-testid=\"home-initial-message\">\n              Digite por um produto ou categoria.\n              <input\n                type=\"text\"\n                name=\"inputQuery\"\n                data-testid=\"query-input\"\n                id=\"queryInput\"\n                onChange={ this.getTextAndCategory }\n              />\n            </label>\n            <button\n              type=\"button\"\n              onClick={ this.requestButton }\n              data-testid=\"query-button\"\n            >\n              Pesquisar\n            </button>\n            <Link\n              to=\"/carrinho\"\n              className=\"cart-button\"\n              data-testid=\"shopping-cart-button\"\n            >\n              Carrinho de compras 🛒\n            </Link>\n          </form>\n          <CardItem\n            className=\"cart-component\"\n            products={ response }\n            addState={ addState }\n          />\n        </div>\n      </div>\n    );\n  }\n}\n\nHome.propTypes = {\n  addState: PropTypes.func.isRequired,\n};\n\nexport default Home;\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\n/** Este componente é responsável por exibir um novo item\n * no carrinho de comprar. Ele é renderizado de forma dinâmica\n * no componente ShoppingCart.jsx, onde algumas props são\n * passadas, incluindo funções e um produto em específico. */\nclass NewItem extends Component {\n  render() {\n    /** Props vindo de App.js */\n    const { product, handleDelete, increaseQuantity, decreaseQuantity } = this.props;\n\n    // const quantity = cart.filter((item) => item === product);\n\n    return (\n      /** Abaixo é gerado um card de um produto adicionado ao carrinho.\n       * Recebe funções de incremento e decremento, para aumentar e diminuir a quantida-\n       * de de itens em um carrinho. */\n      <div>\n        <div key={ product.title }>\n          <p data-testid=\"shopping-cart-product-name\">{product.title}</p>\n          <button type=\"button\" onClick={ () => handleDelete(product) }>X</button>\n          <button\n            type=\"button\"\n            data-testid=\"product-increase-quantity\"\n            onClick={ () => increaseQuantity(product) }\n          >\n            + MAIS\n          </button>\n          <button\n            type=\"button\"\n            data-testid=\"product-decrease-quantity\"\n            onClick={ () => decreaseQuantity(product) }\n          >\n            - MENOS\n          </button>\n          <img src={ product.thumbnail } alt={ product.title } />\n          <p>\n            Valor deste produto: R$\n            {product.price}\n          </p>\n          <span\n            data-testid=\"shopping-cart-product-quantity\"\n          >\n            {`Quandidade selecionada: ${product.quantity}` }\n          </span>\n        </div>\n      </div>\n    );\n  }\n}\n\nNewItem.propTypes = {\n  product: PropTypes.shape({\n    title: PropTypes.string.isRequired,\n    thumbnail: PropTypes.string.isRequired,\n    price: PropTypes.number.isRequired,\n    quantity: PropTypes.number.isRequired,\n  }).isRequired,\n  handleDelete: PropTypes.func.isRequired,\n  increaseQuantity: PropTypes.func.isRequired,\n  decreaseQuantity: PropTypes.func.isRequired,\n};\nexport default NewItem;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport NewItem from '../components/NewItem';\n\nclass ShoppingCart extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      shoppingCart: [],\n    };\n    this.handleDelete = this.handleDelete.bind(this);\n  }\n\n  componentDidMount() {\n    this.filterFunction();\n  }\n\n  /** Função responsável por deletar um item do carrinho de comprar. */\n  handleDelete(product) {\n    /** Esta função faz a seguinte verificação */\n    /** Primeiramente, é recebido o carrinho por props, o carrinho de compras, que é\n     * um array */\n    const { shoppingCart } = this.state;\n\n    /**\n     * 1. Logo, abaixo é criada uma const newList, que receberá um filtro do array\n     * shoppingCart.\n     * 2. Será feita uma verificação, a cada iteração.\n     * 3. Algum \"item\" de \"shoppingCart\" tem uma ID diferente a ID do produto recebido no\n     * parâmetro da função?\n     * 4. Se for diferente, vá adicionando ao \"newList\" */\n    const newList = shoppingCart.filter((item) => item.id !== product.id);\n\n    /** Após o término da iteração, o novo array é criado e adicionado ao State. */\n    this.setState({\n      shoppingCart: newList,\n    });\n  }\n\n  /** Função abaixo é chamada toda vez que o componente é montado,\n   * ou seja, quando se clica em algo que direcione ao /carrinho */\n  filterFunction() {\n    /** A props abaixo vem do componente App.js */\n    const { cart } = this.props;\n\n    /** Basicamente, a função abaixo tem a tarefa de verificar\n     * se um determinado item já se encontra no carrinho.\n     */\n    const result = cart.reduce((acc, curr) => (\n      acc.includes(curr) ? acc : acc.concat(curr)\n    ), []);\n    this.setState({\n      shoppingCart: result,\n    });\n  }\n\n  render() {\n    const { cart, increaseQuantity, decreaseQuantity } = this.props;\n    const { shoppingCart } = this.state;\n\n    const emptyCart = (\n      <h3 data-testid=\"shopping-cart-empty-message\">\n        Seu carrinho está vazio\n      </h3>);\n\n    /** Esta condicional abaixo verifica se o carrinho está vazio.\n       * Caso esteja, renderiza uma mensagem \"Seu carriho está vazio\"\n       * Caso contenha algum item, é feita uma renderização dinâmica\n       * do componente NewItem. De acordo com a quantidade itens no\n       * carrinho, será a quantidade de iterações que o .map irá fazer\n       * abaixo */\n    return !cart.length ? emptyCart : shoppingCart.map((product, index) => (\n      <NewItem\n      /** Para NewItem, são passadas algunas props como o \"product\" que\n       * está sendo trabalhado na iteração recorrente, passado \"handleDelete\",\n       * que tem a função de teletar um item do carrinho, \"increaseQuantity\" e\n       * \"decreaseQuantity\", que tem função de incrementar e decrementar, respe-\n       * ctivamente */\n        product={ product }\n        key={ index }\n        handleDelete={ this.handleDelete }\n        increaseQuantity={ increaseQuantity }\n        decreaseQuantity={ decreaseQuantity }\n      />\n    ));\n  }\n}\n\nShoppingCart.propTypes = {\n  cart: PropTypes.shape({\n    map: PropTypes.func.isRequired,\n    length: PropTypes.arrayOf().isRequired,\n    reduce: PropTypes.func.isRequired,\n  }).isRequired,\n  increaseQuantity: PropTypes.func.isRequired,\n  decreaseQuantity: PropTypes.func.isRequired,\n};\n\nexport default ShoppingCart;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { Link } from 'react-router-dom';\n\nclass Details extends React.Component {\n  /*\n  // constructor() {\n  //   super();\n  //   this.state = {\n  //     products: [],\n  //   }\n  // }\n\n  // // async getItemsFromCategoryAndQuery(category, inputQuery) {\n  // //   const request = await api.getProductsFromCategoryAndQuery(category, inputQuery);\n  // //   console.log('AQUI', request)\n  // //   this.setState({\n  // //     product: request.results,\n  // //   });\n  // // }\n\n  // // componentDidMount() {\n  // //   const { match } = this.props;\n  // //   const { params } = match;\n  // //   const { id } = params;\n  // //   const { products } = this.props.location.state\n  // //   console.log('NOSSO TESTE', products)\n  // //   this.handleState(products)\n  // // }\n\n  //    handleState(products) {\n  //    this.setState({\n  //     products,\n  //   });\n  // }\n  */\n  render() {\n    const { addState } = this.props;\n    /** Desestruturação abaixo: vindo do componente Link\n     * em cardItem.jsx */\n    const { location: { state: { product } } } = this.props;\n\n    return (\n      <div\n        key={ product.title }\n      >\n        <p data-testid=\"product-detail-name\">{product.title}</p>\n        <img src={ product.thumbnail } alt={ product.title } />\n        <p>{product.price}</p>\n        <button\n          type=\"button\"\n          onClick={ () => addState(product) }\n          data-testid=\"product-detail-add-to-cart\"\n        >\n          Adicionar ao carrinho\n        </button>\n        <Link\n          to=\"/carrinho\"\n          data-testid=\"shopping-cart-button\"\n        >\n          Carrinho de compras\n        </Link>\n      </div>\n    );\n  }\n}\n\nDetails.propTypes = {\n  location: PropTypes.shape({\n    state: PropTypes.shape({\n      product: PropTypes.shape({\n        title: PropTypes.string,\n        price: PropTypes.number,\n        thumbnail: PropTypes.string,\n      }),\n    }),\n  }).isRequired,\n  addState: PropTypes.func.isRequired,\n};\n\nexport default Details;\n","import React from 'react';\nimport './App.css';\nimport { BrowserRouter, Route, Switch } from 'react-router-dom';\nimport Home from './pages/Home';\nimport ShoppingCart from './pages/ShoppingCart';\nimport Details from './pages/Details';\n\nclass App extends React.Component {\n  constructor() {\n    super();\n    this.state = { cart: [] };\n\n    this.addState = this.addState.bind(this);\n    this.increaseQuantity = this.increaseQuantity.bind(this);\n    this.decreaseQuantity = this.decreaseQuantity.bind(this);\n  }\n\n  /** Esta função \"addState\" é responsável por adicionar um item ao carrinho.\n   * Basicamente, ele recebe por parâmetro um produto específico. Esse parâmetro\n   * é um item que apareceu na home, assim que uma requisição é feita, ou na\n   * página de detalhes.\n   * Isto é, Details.jsx e CardItem.jsx tem o addState para esta tarefa. */\n  addState(product) {\n    /** Variável que será editada, por isso em let it change 👀 */\n    let newCart = [];\n    const { cart } = this.state;\n\n    /** A const anyProduct será criada de acordo com um item que foi\n     * passado por parâmetro na função \"addState\". Será passado um\n     * .find() no cart, que vem do state, que deve ser um array de objetos.\n     * AnyProduct será a const responsável por armazenar o primeiro\n     * produto que satisfaça a condição do .find(). Logo mais pra frente,\n     * há uma verificação: Se o ID de item === ID do produto passado por\n     * parâmetro em \"addState\", traga esse produto para mim e jogue na variável\n     * anyProduct. */\n    const anyProduct = cart.find((item) => item.id === product.id);\n\n    /** Caso a condição for atendida acima, anyProduct ficará true, e passará na\n     * condicional abaixo */\n    if (anyProduct) {\n      /** newCart, pelo fato de ser let, pode ser modificada. Então, a cada itera-\n       * ção do .map() abaixo irá veficiar se algum ID de \"item\" === ao ID do anyProduct.\n       * Caso for igual, adicione +=1 na quantidade deste item e depois retorne-o.\n       */\n      newCart = cart.map((item) => {\n        if (item.id === anyProduct.id) {\n          item.quantity += 1;\n          return item;\n        }\n        return item;\n      });\n    } else {\n      /** Caso o produto ainda não exista no carrinho, será adicionado\n       *  uma chave chamada \"quantity\" e o valor dela será 1, significando\n       * que é o primeiro produto daquele tipo no carrinho */\n      product.quantity = 1;\n      /** Aqui abaixo é feita a junção do carrinho com o produto, utilizando\n       * spread, é como se fosse um .push(), mas o mesmo não deve ser utilizado\n       * devido a problemas relacionados ao React, onde ele em vez dele unificar\n       * o array, ele faz algo do tipo:\n       * [Array anterior, [novo array]] */\n      newCart = [...cart, product];\n    }\n    /** Após o ocorrido, o newCart é adicicionado ao cart */\n    this.setState(() => ({ cart: newCart }));\n  }\n\n  /** Função responsável por incrementar a quantidade de itens ao carrinho. */\n  increaseQuantity(product) {\n    const { cart } = this.state;\n    const newArr = cart.map((item) => {\n      if (item.id === product.id) {\n        item.quantity += 1;\n        return item;\n      }\n      return item;\n    });\n    this.setState({\n      cart: newArr,\n    });\n  }\n\n  /** Função responsável por decrementar a quantidade de itens ao carrinho. */\n  decreaseQuantity(product) {\n    const { cart } = this.state;\n    const newArr = cart.map((item) => {\n      if (item.id === product.id && item.quantity > 0) {\n        item.quantity -= 1;\n        return item;\n      }\n      return item;\n    });\n    this.setState({\n      cart: newArr,\n    });\n  }\n\n  render() {\n    const { cart } = this.state;\n    return (\n      <div>\n        <BrowserRouter basename={ process.env.PUBLIC_URL }>\n          <Switch>\n            <Route exact path=\"/\" render={ () => <Home addState={ this.addState } /> } />\n            <Route\n              exact\n              path=\"/carrinho\"\n              render={ () => (<ShoppingCart\n                cart={ cart }\n                decreaseQuantity={ this.decreaseQuantity }\n                increaseQuantity={ this.increaseQuantity }\n              />) }\n            />\n            <Route\n              exact\n              path=\"/details/:id\"\n              render={ (props) => (<Details { ...props } addState={ this.addState } />) }\n            />\n          </Switch>\n        </BrowserRouter>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost'\n    // [::1] is the IPv6 localhost address.\n    || window.location.hostname === '[::1]'\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    || window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/,\n    ),\n);\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all '\n                  + 'tabs for this page are closed. See https://bit.ly/CRA-PWA.',\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  const NOT_FOUND = 404;\n  const NOT_FOUND_IN_ARRAY = -1;\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  }).then((response) => {\n    // Ensure service worker exists, and that we really are getting a JS file.\n    const contentType = response.headers.get('content-type');\n    if (response.status === NOT_FOUND\n        || (contentType != null\n          && contentType.indexOf('javascript') === NOT_FOUND_IN_ARRAY)) {\n      // No service worker found. Probably a different app. Reload the page.\n      navigator.serviceWorker.ready.then((registration) => {\n        registration.unregister().then(() => {\n          window.location.reload();\n        });\n      });\n    } else {\n      // Service worker found. Proceed as normal.\n      registerValidSW(swUrl, config);\n    }\n  })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.',\n      );\n    });\n}\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service '\n              + 'worker. To learn more, visit https://bit.ly/CRA-PWA',\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}